use fatfs::{FileSystem, FormatVolumeOptions, FsOptions};
use gpt::disk::LogicalBlockSize;
use gpt::mbr::ProtectiveMBR;
use gpt::partition_types::EFI;
use gpt::GptConfig;
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::collections::{BTreeMap, HashMap};
use std::fmt::Write;
use std::fs::{create_dir_all, File};
use std::io::{BufRead, BufReader, Cursor};
use std::ops::{Deref, DerefMut};
use std::panic::panic_any;
use std::path::{Path, PathBuf};
use std::process::{Child, Command, Stdio};
use std::sync::{Arc, Mutex};

/// Generate a Cargo project in `dest` with `name` as a project name and `body` as a body of
/// `efi_main`.
///
/// The project will be created as a sub-directory of `dest`.
pub fn gen_qemu_test(proj: PathBuf, mut root: PathBuf, name: &str, body: &str) -> PathBuf {
    // Generate a unique name for root directory.
    root.push(format!("{}-{}", name, blake3::hash(body.as_bytes())));

    // Create project directory.
    let dest = root.join("project");

    create_dir_all(&dest).unwrap();

    // Copy dev-dependencies from the project.
    let cargo = std::fs::read_to_string(proj.join("Cargo.toml")).unwrap();
    let mut cargo = toml::from_str::<Cargo>(&cargo).unwrap();

    cargo.dev_dependencies.remove("zfi-testing");
    cargo.dependencies.extend(cargo.dev_dependencies.drain());

    // Convert relative path to full path.
    for dep in cargo.dependencies.values_mut() {
        let path = match dep {
            Dependency::Complex {
                version: _,
                path: Some(v),
            } => v,
            _ => continue,
        };

        if !Path::new(path.as_str()).is_relative() {
            continue;
        }

        *path = proj
            .join(path.as_str())
            .canonicalize()
            .unwrap()
            .into_os_string()
            .into_string()
            .unwrap();
    }

    // Check if the test being run is our test.
    if cargo.package.take().unwrap().name == "zfi" {
        cargo.dependencies.remove("zfi-macros");
        cargo.dependencies.insert(
            String::from("zfi"),
            Dependency::Complex {
                version: None,
                path: Some(proj.into_os_string().into_string().unwrap()),
            },
        );
    }

    // Create Cargo.toml.
    let mut data = String::new();

    writeln!(data, r#"[package]"#).unwrap();
    writeln!(data, r#"name = "{name}""#).unwrap();
    writeln!(data, r#"version = "0.1.0""#).unwrap();
    writeln!(data, r#"edition = "2021""#).unwrap();
    writeln!(data).unwrap();
    data.push_str(&toml::to_string_pretty(&cargo).unwrap());
    writeln!(data).unwrap();
    writeln!(data, r#"[workspace]"#).unwrap();
    writeln!(data, r#"members = []"#).unwrap();

    std::fs::write(dest.join("Cargo.toml"), data).unwrap();

    // Create src directory.
    let mut path = dest.join("src");

    create_dir_all(&path).unwrap();

    // Generate src/main.rs.
    let mut data = String::new();

    writeln!(data, r#"#![no_std]"#).unwrap();
    writeln!(data, r#"#![no_main]"#).unwrap();
    writeln!(data).unwrap();
    writeln!(data, r#"#[::zfi::main(no_ph)]"#).unwrap();
    writeln!(data, r#"fn main() -> ::zfi::Status {{"#).unwrap();
    writeln!(data, r#"{}"#, &body[1..(body.len() - 1)]).unwrap();
    writeln!(data, r#"    ::zfi::println!("zfi:ok");"#).unwrap();
    writeln!(data, r#"    loop {{}}"#).unwrap();
    writeln!(data, r#"}}"#).unwrap();
    writeln!(data).unwrap();
    writeln!(data, r#"#[panic_handler]"#).unwrap();
    writeln!(
        data,
        r#"fn panic_handler(i: &::core::panic::PanicInfo) -> ! {{"#
    )
    .unwrap();
    writeln!(data, r#"    let l = i.location().unwrap();"#).unwrap();
    writeln!(data).unwrap();
    writeln!(
        data,
        r#"    ::zfi::println!("zfi:panic:{{}}:{{}}:{{}}", l.file(), l.line(), l.column());"#
    )
    .unwrap();
    writeln!(data, r#"    ::zfi::println!("{{}}", i.message());"#).unwrap();
    writeln!(data, r#"    ::zfi::println!("zfi:end");"#).unwrap();
    writeln!(data).unwrap();
    writeln!(data, r#"    loop {{}}"#).unwrap();
    writeln!(data, r#"}}"#).unwrap();

    // Write src/main.rs.
    path.push("main.rs");

    std::fs::write(&path, data).unwrap();

    root
}

/// Run the project that was generated by [`qemu`] attribute.
pub fn run_qemu_test<P: AsRef<Path>>(root: P) {
    let root = root.as_ref();

    // Load the config.
    let config = std::fs::read_to_string("zfi.toml")
        .expect("cannot read zfi.toml on the root of the package");
    let config = toml::from_str::<Config>(&config)
        .expect("cannot parse zfi.toml on the root of the package")
        .qemu;

    for (target, qemu) in config {
        run_test(root, &target, &qemu);
    }
}

fn run_test(root: &Path, target: &str, config: &QemuConfig) {
    // Build the project.
    let project = root.join("project");
    let status = Command::new("cargo")
        .current_dir(&project)
        .arg("install")
        .args(["--target", target])
        .args(["--path", "."])
        .args(["--root", "."])
        .arg("--debug")
        .arg("--quiet")
        .stdin(Stdio::null())
        .status()
        .unwrap_or_else(|e| {
            panic!(
                "cannot spawn cargo on {} for {} target: {}",
                project.display(),
                target,
                e
            )
        });

    if !status.success() {
        panic!(
            "build {} for {} was failed with {}",
            project.display(),
            target,
            status
        );
    }

    // Get ptoject name.
    let name = std::fs::read_to_string(project.join("Cargo.toml"))
        .unwrap_or_else(|e| panic!("cannot read Cargo.toml from {}: {}", project.display(), e))
        .parse::<toml::Table>()
        .unwrap_or_else(|e| panic!("cannot parse Cargo.toml from {}: {}", project.display(), e))
        .get("package")
        .unwrap()
        .as_table()
        .unwrap()
        .get("name")
        .unwrap()
        .as_str()
        .unwrap()
        .to_owned();

    // Get path to the binary.
    let mut bin = project.join("bin");

    bin.push(name);
    bin.set_extension("efi");

    // Create a VM disk.
    let size = 512 * 2048 * 2;
    let mut disk = Cursor::new(vec![0; size]);

    ProtectiveMBR::with_lb_size(u32::try_from((size / 512) - 1).unwrap_or(0xFFFFFFFF))
        .overwrite_lba0(&mut disk)
        .expect("cannot write MBR");

    // Create a GPT.
    let mut gpt = GptConfig::new()
        .initialized(false)
        .writable(true)
        .create_from_device(Box::new(&mut disk), None)
        .expect("cannot create a GPT");

    gpt.update_partitions(BTreeMap::new())
        .expect("cannot initialize the GTP");

    // Create EFI partition.
    let part = gpt
        .add_partition("zfi", 512 * 2048, EFI, 0, None)
        .expect("cannot create an EFI system partition");
    let part = gpt.partitions().get(&part).unwrap();
    let offset: usize = part
        .bytes_start(LogicalBlockSize::Lb512)
        .unwrap()
        .try_into()
        .unwrap();
    let size: usize = part
        .bytes_len(LogicalBlockSize::Lb512)
        .unwrap()
        .try_into()
        .unwrap();

    gpt.write().unwrap();

    // Format EFI partition.
    let mut data = disk.into_inner();

    fatfs::format_volume(
        Cursor::new(&mut data[offset..(offset + size)]),
        FormatVolumeOptions::new(),
    )
    .expect("cannot format EFI system partition");

    // Put binary to EFI/boot.
    std::io::copy(
        &mut File::open(&bin).unwrap(),
        &mut FileSystem::new(
            Cursor::new(&mut data[offset..(offset + size)]),
            FsOptions::new(),
        )
        .unwrap()
        .root_dir()
        .create_dir("EFI")
        .unwrap()
        .create_dir("boot")
        .unwrap()
        .create_file(match target {
            "aarch64-unknown-uefi" => "bootaa64.efi",
            "i686-unknown-uefi" => "bootia32.efi",
            "x86_64-unknown-uefi" => "bootx64.efi",
            v => todo!("target {v}"),
        })
        .unwrap(),
    )
    .unwrap_or_else(|e| {
        panic!(
            "cannot put {} to the EFI system partition: {}",
            bin.display(),
            e
        )
    });

    // Create a VM directory.
    let vm = root.join("vm");

    create_dir_all(&vm).unwrap_or_else(|e| panic!("cannot create {}: {}", vm.display(), e));

    // Write the disk.
    let disk = vm.join("disk.img");

    std::fs::write(&disk, &data)
        .unwrap_or_else(|e| panic!("cannot create {}: {}", disk.display(), e));

    // Copy UEFI NVRAM.
    let nvram = vm.join("nvram.fd");

    std::fs::copy(&config.nvram, &nvram)
        .unwrap_or_else(|e| panic!("cannot copy {} to {}: {}", config.nvram, vm.display(), e));

    // Setup QEMU common arguments.
    let mut qemu = Command::new(&config.bin);

    qemu.stdin(Stdio::null())
        .stdout(Stdio::piped())
        .arg("-nographic")
        .arg("-drive")
        .arg(format!(
            "if=pflash,format=raw,readonly=on,file={}",
            config.firmware
        ))
        .arg("-drive")
        .arg(format!(
            "if=pflash,format=raw,file={}",
            nvram.to_str().unwrap()
        ))
        .arg("-drive")
        .arg(format!(
            "if=virtio,format=raw,file={}",
            disk.to_str().unwrap()
        ));

    if target == "aarch64-unknown-uefi" {
        qemu.args(["-machine", "virt"]);
        qemu.args(["-cpu", "cortex-a57"]);
    }

    // Spawn QEMU.
    let mut qemu = qemu
        .spawn()
        .unwrap_or_else(|e| panic!("cannot spawn {}: {}", config.bin, e));

    // Associate QEMU to a panic handler so it will get killed if panic=abort.
    let mut stdout = BufReader::new(qemu.stdout.take().unwrap());
    let qemu = Arc::new(Mutex::new(Some(Process(qemu))));
    let hook = std::panic::take_hook();

    {
        let qemu = qemu.clone();

        std::panic::set_hook(Box::new(move |i| {
            *qemu.lock().unwrap() = None;
            hook(i);
        }));
    }

    // Read our command.
    let mut line = String::new();
    let mut block: Option<(Block, String)> = None;

    loop {
        // Read the line.
        line.clear();

        if stdout
            .read_line(&mut line)
            .expect("cannot read QEMU output")
            == 0
        {
            panic!("the communication with QEMU was closed");
        }

        // Parse the command.
        let (cmd, _) = if let Some(data) = line.strip_prefix("zfi:") {
            match data.split_once(':') {
                Some((l, r)) => (l, r.trim_end()),
                None => (data.trim_end(), ""),
            }
        } else {
            if let Some(v) = &mut block {
                v.1.push_str(&line);
            }

            continue;
        };

        // Process the command.
        match cmd {
            "end" => {
                let (ty, block) = block.take().unwrap();

                match ty {
                    Block::Panic => report_failure(block.trim_end()),
                }
            }
            "ok" => break,
            "panic" => block = Some((Block::Panic, String::new())),
            v => panic!("unknown command '{v}' from QEMU"),
        }
    }

    *qemu.lock().unwrap() = None;
}

fn report_failure(msg: &str) {
    // Right now PanicInfo does not have any payload for no_std. So our only choice is using its
    // Display implementation then trim its result.
    panic_any(if msg.starts_with("panicked at '") {
        let r = Regex::new(r"(?s)^panicked at '(.*?)', (.+?):(\d+):(\d+)$").unwrap();
        let m = r.captures(msg).unwrap();
        let mut d = String::new();

        writeln!(
            d,
            "QEMU test failed: {}:{}:{}",
            m.get(2).unwrap().as_str(),
            m.get(3).unwrap().as_str(),
            m.get(4).unwrap().as_str()
        )
        .unwrap();

        d.push_str(m.get(1).unwrap().as_str());
        d
    } else {
        msg.to_owned()
    });
}

#[derive(Serialize, Deserialize)]
struct Cargo {
    package: Option<Package>,
    dependencies: HashMap<String, Dependency>,

    #[serde(rename = "dev-dependencies")]
    dev_dependencies: HashMap<String, Dependency>,
}

#[derive(Serialize, Deserialize)]
struct Package {
    name: String,
}

#[derive(Serialize, Deserialize)]
#[serde(untagged)]
enum Dependency {
    Simple(String),
    Complex {
        version: Option<String>,
        path: Option<String>,
    },
}

#[derive(Deserialize)]
struct Config {
    qemu: HashMap<String, QemuConfig>,
}

#[derive(Deserialize)]
struct QemuConfig {
    bin: String,
    firmware: String,
    nvram: String,
}

struct Process(Child);

impl Drop for Process {
    fn drop(&mut self) {
        let _ = self.0.kill();
        self.0.wait().unwrap();
    }
}

impl Deref for Process {
    type Target = Child;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for Process {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

enum Block {
    Panic,
}
