use fatfs::{FileSystem, FormatVolumeOptions, FsOptions};
use gpt::disk::LogicalBlockSize;
use gpt::mbr::ProtectiveMBR;
use gpt::partition_types::EFI;
use gpt::GptConfig;
use regex::Regex;
use serde::Deserialize;
use std::collections::{BTreeMap, HashMap};
use std::fmt::Write;
use std::fs::{create_dir_all, File};
use std::io::{BufRead, BufReader, Cursor};
use std::ops::{Deref, DerefMut};
use std::panic::panic_any;
use std::path::Path;
use std::process::{Child, Command, Stdio};
use std::sync::{Arc, Mutex};

/// Run the project that was generated by [`qemu`] attribute.
pub fn run_qemu_test<P: AsRef<Path>>(root: P) {
    let root = root.as_ref();

    // Load the config.
    let config = std::fs::read_to_string("zfi.toml")
        .expect("cannot read zfi.toml on the root of the package");
    let config = toml::from_str::<Config>(&config)
        .expect("cannot parse zfi.toml on the root of the package")
        .qemu;

    for (target, qemu) in config {
        run_test(root, &target, &qemu);
    }
}

fn run_test(root: &Path, target: &str, config: &QemuConfig) {
    // Build the project.
    let project = root.join("project");
    let status = Command::new("cargo")
        .current_dir(&project)
        .arg("install")
        .args(["--target", target])
        .args(["--path", "."])
        .args(["--root", "."])
        .arg("--debug")
        .arg("--quiet")
        .stdin(Stdio::null())
        .status()
        .unwrap_or_else(|e| {
            panic!(
                "cannot spawn cargo on {} for {} target: {}",
                project.display(),
                target,
                e
            )
        });

    if !status.success() {
        panic!(
            "build {} for {} was failed with {}",
            project.display(),
            target,
            status
        );
    }

    // Get ptoject name.
    let name = std::fs::read_to_string(project.join("Cargo.toml"))
        .unwrap_or_else(|e| panic!("cannot read Cargo.toml from {}: {}", project.display(), e))
        .parse::<toml::Table>()
        .unwrap_or_else(|e| panic!("cannot parse Cargo.toml from {}: {}", project.display(), e))
        .get("package")
        .unwrap()
        .as_table()
        .unwrap()
        .get("name")
        .unwrap()
        .as_str()
        .unwrap()
        .to_owned();

    // Get path to the binary.
    let mut bin = project.join("bin");

    bin.push(name);
    bin.set_extension("efi");

    // Create a VM disk.
    let size = 512 * 2048 * 2;
    let mut disk = Cursor::new(vec![0; size]);

    ProtectiveMBR::with_lb_size(u32::try_from((size / 512) - 1).unwrap_or(0xFFFFFFFF))
        .overwrite_lba0(&mut disk)
        .expect("cannot write MBR");

    // Create a GPT.
    let mut gpt = GptConfig::new()
        .initialized(false)
        .writable(true)
        .create_from_device(Box::new(&mut disk), None)
        .expect("cannot create a GPT");

    gpt.update_partitions(BTreeMap::new())
        .expect("cannot initialize the GTP");

    // Create EFI partition.
    let part = gpt
        .add_partition("zfi", 512 * 2048, EFI, 0, None)
        .expect("cannot create an EFI system partition");
    let part = gpt.partitions().get(&part).unwrap();
    let offset: usize = part
        .bytes_start(LogicalBlockSize::Lb512)
        .unwrap()
        .try_into()
        .unwrap();
    let size: usize = part
        .bytes_len(LogicalBlockSize::Lb512)
        .unwrap()
        .try_into()
        .unwrap();

    gpt.write().unwrap();

    // Format EFI partition.
    let mut data = disk.into_inner();

    fatfs::format_volume(
        Cursor::new(&mut data[offset..(offset + size)]),
        FormatVolumeOptions::new(),
    )
    .expect("cannot format EFI system partition");

    // Put binary to EFI/boot.
    std::io::copy(
        &mut File::open(&bin).unwrap(),
        &mut FileSystem::new(
            Cursor::new(&mut data[offset..(offset + size)]),
            FsOptions::new(),
        )
        .unwrap()
        .root_dir()
        .create_dir("EFI")
        .unwrap()
        .create_dir("boot")
        .unwrap()
        .create_file(match target {
            "x86_64-unknown-uefi" => "bootx64.efi",
            v => todo!("target {v}"),
        })
        .unwrap(),
    )
    .unwrap_or_else(|e| {
        panic!(
            "cannot put {} to the EFI system partition: {}",
            bin.display(),
            e
        )
    });

    // Create a VM directory.
    let vm = root.join("vm");

    create_dir_all(&vm).unwrap_or_else(|e| panic!("cannot create {}: {}", vm.display(), e));

    // Write the disk.
    let disk = vm.join("disk.img");

    std::fs::write(&disk, &data)
        .unwrap_or_else(|e| panic!("cannot create {}: {}", disk.display(), e));

    // Copy UEFI NVRAM.
    let nvram = vm.join("nvram.fd");

    std::fs::copy(&config.nvram, &nvram)
        .unwrap_or_else(|e| panic!("cannot copy {} to {}: {}", config.nvram, vm.display(), e));

    // Spawn QEMU.
    let mut qemu = Command::new(&config.bin)
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::null())
        .arg("-nographic")
        .arg("-drive")
        .arg(format!(
            "if=pflash,format=raw,readonly=on,file={}",
            config.firmware
        ))
        .arg("-drive")
        .arg(format!(
            "if=pflash,format=raw,file={}",
            nvram.to_str().unwrap()
        ))
        .arg("-drive")
        .arg(format!(
            "if=virtio,format=raw,file={}",
            disk.to_str().unwrap()
        ))
        .spawn()
        .unwrap_or_else(|e| panic!("cannot spawn {}: {}", config.bin, e));

    // Associate QEMU to a panic handler so it will get killed if panic=abort.
    let mut stdout = BufReader::new(qemu.stdout.take().unwrap());
    let qemu = Arc::new(Mutex::new(Some(Process(qemu))));
    let hook = std::panic::take_hook();
    let qemu_copy = qemu.clone();

    std::panic::set_hook(Box::new(move |i| {
        *qemu_copy.lock().unwrap() = None;
        hook(i);
    }));

    // Read our command.
    let mut line = String::new();
    let mut block: Option<(Block, String)> = None;

    loop {
        // Read the line.
        line.clear();

        if stdout
            .read_line(&mut line)
            .expect("cannot read QEMU output")
            == 0
        {
            panic!("the communication with QEMU was closed");
        }

        // Parse the command.
        let (cmd, _) = if let Some(data) = line.strip_prefix("zfi:") {
            match data.split_once(':') {
                Some((l, r)) => (l, r.trim_end()),
                None => (data.trim_end(), ""),
            }
        } else {
            if let Some(v) = &mut block {
                v.1.push_str(&line);
            }

            continue;
        };

        // Process the command.
        match cmd {
            "end" => {
                let (ty, block) = block.take().unwrap();

                match ty {
                    Block::Panic => report_failure(block.trim_end()),
                }
            }
            "ok" => break,
            "panic" => block = Some((Block::Panic, String::new())),
            v => panic!("unknown command '{v}' from QEMU"),
        }
    }

    *qemu.lock().unwrap() = None;
}

fn report_failure(msg: &str) {
    // Right now PanicInfo does not have any payload for no_std. So our only choice is using its
    // Display implementation then trim its result.
    panic_any(if msg.starts_with("panicked at '") {
        let r = Regex::new(r"(?s)^panicked at '(.*?)', (.+?):(\d+):(\d+)$").unwrap();
        let m = r.captures(msg).unwrap();
        let mut d = String::new();

        writeln!(
            d,
            "QEMU test failed: {}:{}:{}",
            m.get(2).unwrap().as_str(),
            m.get(3).unwrap().as_str(),
            m.get(4).unwrap().as_str()
        )
        .unwrap();

        d.push_str(m.get(1).unwrap().as_str());
        d
    } else {
        msg.to_owned()
    });
}

#[derive(Deserialize)]
struct Config {
    qemu: HashMap<String, QemuConfig>,
}

#[derive(Deserialize)]
struct QemuConfig {
    bin: String,
    firmware: String,
    nvram: String,
}

struct Process(Child);

impl Drop for Process {
    fn drop(&mut self) {
        let _ = self.0.kill();
        self.0.wait().unwrap();
    }
}

impl Deref for Process {
    type Target = Child;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for Process {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

enum Block {
    Panic,
}
